{% extends 'base.html' %}
{% block title %}Module 1 | Benkyo-Fi{% endblock %}
{% block content %}
<section class="panel">
	<div class="header-with-settings">
		<h1>Spaced repetition flashcards (SRF)</h1>
		<div class="settings-dropdown">
			<button class="settings-btn" onclick="toggleSettings()">⚙️</button>
			<div class="settings-panel" id="settingsPanel">
				<form method="POST" action="{{ url_for('module1.update_settings') }}">
					<div class="settings-section">
						<h3>Flashcard Style:</h3>
						<div class="checkbox-group">
							<label><input type="checkbox" name="flashcard_hiragana" {% if 'hiragana' in settings.flashcard_styles %}checked{% endif %}> Hiragana</label>
							<label><input type="checkbox" name="flashcard_kanji" {% if 'kanji' in settings.flashcard_styles %}checked{% endif %}> Kanji</label>
							<label><input type="checkbox" name="flashcard_katakana" {% if 'katakana' in settings.flashcard_styles %}checked{% endif %}> Katakana</label>
							<label><input type="checkbox" name="flashcard_english" {% if 'english' in settings.flashcard_styles %}checked{% endif %}> English</label>
						</div>
					</div>
					<div class="settings-section">
						<h3>Checking Style:</h3>
						<div class="checkbox-group">
							<label><input type="checkbox" name="checking_hiragana" {% if 'hiragana' in settings.checking_styles %}checked{% endif %}> Hiragana <span class="note">(converts romaji → hiragana as you type)</span></label>
							<label><input type="checkbox" name="checking_romaji" {% if 'romaji' in settings.checking_styles %}checked{% endif %}> Romaji <span class="note">(keeps romaji as you type)</span></label>
							<label><input type="checkbox" name="checking_kanji" {% if 'kanji' in settings.checking_styles %}checked{% endif %}> Kanji</label>
							<label><input type="checkbox" name="checking_katakana" {% if 'katakana' in settings.checking_styles %}checked{% endif %}> Katakana</label>
							<label><input type="checkbox" name="checking_english" {% if 'english' in settings.checking_styles %}checked{% endif %}> English</label>
						</div>
					</div>
					<div class="settings-actions">
						<button type="submit" class="btn btn-small">Save Settings</button>
					</div>
				</form>
			</div>
		</div>
	</div>
	<div class="prompt">
		<p class="muted">Prompt ({{ item.prompt_script }})</p>
		<div class="prompt-value">{{ item.prompt }}</div>
	</div>
	<div class="answer-form">
		{% set has_hiragana_romaji = 'hiragana' in settings.checking_styles or 'romaji' in settings.checking_styles %}
		{% set other_styles = settings.checking_styles | reject('in', ['hiragana', 'romaji']) | list %}
		
		{% if has_hiragana_romaji %}
		<div class="input-group">
			{% set hiragana_label = 'hiragana' in settings.checking_styles %}
			{% set romaji_label = 'romaji' in settings.checking_styles %}
			<label for="user_hiragana_romaji">
				Your answer (
				{%- if hiragana_label and romaji_label -%}
					hiragana/romaji
				{%- elif hiragana_label -%}
					hiragana
				{%- else -%}
					romaji
				{%- endif -%}
				):
			</label>
			<input type="text" 
				   id="user_hiragana_romaji" 
				   name="user_hiragana_romaji" 
				   class="answer-input" 
				   placeholder="Type in romaji..." 
				   autofocus 
				   autocomplete="off" 
				   autocorrect="off" 
				   autocapitalize="off" 
				   spellcheck="false" />
		</div>
		{% endif %}
		
		{% for style in other_styles %}
		<div class="input-group">
			<label for="user_{{ style }}">Your answer ({{ style }}):</label>
			<input type="text" 
				   id="user_{{ style }}" 
				   name="user_{{ style }}" 
				   class="answer-input" 
				   placeholder="Type {{ style }}..." 
				   autocomplete="off" 
				   autocorrect="off" 
				   autocapitalize="off" 
				   spellcheck="false" />
		</div>
		{% endfor %}
	</div>	
	<input type="hidden" id="item_id" name="item_id" value="{{ item.index }}">

	<div class="actions">
		<button type="button" class="btn" onclick="handleCheckAnswers()">benkyfy</button>
	</div>
	
	<!-- Always render the results container -->
	<div class="results-container">
		<!-- Initial content can be empty or a placeholder -->
	</div>

	{% if results is not none %}
	<div class="overall-result {{ 'correct' if all_correct else 'incorrect' }}">
		<p><strong>{{ 'All Correct!' if all_correct else 'Some Incorrect' }}</strong></p>
	</div>
		
				{% for style, result in results.items() %}
	<div class="result {{ 'correct' if result.is_correct else 'incorrect' }}">
		<h4>{{ style.title() }}</h4>
		<p>Your answer: <code>{{ result.user_input or '(empty)' }}</code></p>
		<p>Correct answer: <code>{{ result.correct_answer }}</code></p>
		<p class="result-status">{{ '✓ Correct' if result.is_correct else '✗ Incorrect' }}</p>
	</div>
	{% endfor %}

	<button class="btn" onclick="goToNext()">
		Next ➡️
	</button>

	{% endif %}
  
  
</section>

<script src="{{ url_for('static', filename='js/utils.js') }}"></script>

<script>
function toggleSettings() {
	const panel = document.getElementById('settingsPanel');
	panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
}

function goToNext() {
	window.location.href = "{{ url_for('module1.module1_index') }}";
}

// Close settings panel when clicking outside
document.addEventListener('click', function(e) {
	const settingsDropdown = document.querySelector('.settings-dropdown');
	const settingsPanel = document.getElementById('settingsPanel');
	if (!settingsDropdown.contains(e.target)) {
		settingsPanel.style.display = 'none';
	}
});

// Now you can use convertRomajiToHiragana directly in your existing code

function getFriendlyStyleName(style) {
    const styleMap = {
        'hiragana_romaji': 'Hiragana/Romaji',
        'hiragana': 'Hiragana',
        'romaji': 'Romaji',
        'kanji': 'Kanji',
        'katakana': 'Katakana',
        'english': 'English'
    };
    return styleMap[style] || style.charAt(0).toUpperCase() + style.slice(1);
}

function fetchCorrectAnswers() {
    // Get the item ID from the hidden input
    const itemId = document.getElementById('item_id').value;
    
    // Define the API endpoint with item_id parameter
    const apiUrl = `/module1/api/correct-answers?item_id=${itemId}`;

    // Make the API request
    return fetch(apiUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            // Return the data directly since it's already in the correct format
            return data;
        })
        .catch(error => {
            console.error('Error fetching correct answers:', error);
            return null;
        });
}

document.addEventListener('DOMContentLoaded', function() {
    let resultsShown = false; // Define resultsShown in the correct scope

    // Initialize panel color to waiting state
    const panel = document.querySelector('.panel');
    if (panel) {
        panel.classList.add('waiting'); // White for waiting answer
    }

    function updateButton() {
        const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
        if (button) {
            if (resultsShown) {
                button.textContent = '+1';
                button.classList.add('next-button');
                button.classList.remove('check-button');
            } else {
                button.textContent = 'benkyfy';
                button.classList.add('check-button');
                button.classList.remove('next-button');
            }
        }
    }

    function resetPanelColor() {
        const panel = document.querySelector('.panel');
        if (panel) {
            panel.classList.remove('waiting', 'correct', 'incorrect');
            panel.classList.add('waiting'); // Reset to white waiting state
        }
    }

    function handleCheckAnswers(event) {
        if (event) {
            event.preventDefault(); // Prevent default behavior
        }

        if (resultsShown) {
            resetOrNext();
            return;
        }

        // Retrieve user inputs
        const userInputs = {};
        const inputElements = document.querySelectorAll('.answer-input');
        inputElements.forEach(input => {
            userInputs[input.name] = input.value.trim();
        });

        // Fetch correct answers
        fetchCorrectAnswers().then(correctAnswers => {
            if (!correctAnswers) {
                console.error('Failed to fetch correct answers');
                return;
            }

            // Compare user inputs with correct answers
            const results = {};
            let allCorrect = true;
            
            console.log('=== Answer Check Results ===');
            
            for (const [key, userInput] of Object.entries(userInputs)) {
                const correctAnswerText = correctAnswers[key];
                let isCorrect = false;
                
                // Handle multiple correct answers for English (separated by " / ")
                if (key === "user_english" && correctAnswerText) {
                    const correctAnswersArray = correctAnswerText.split(" / ").map(answer => answer.trim().toLowerCase());
                    isCorrect = correctAnswersArray.includes(userInput.toLowerCase());
                } else {
                    // Simple exact match for other types
                    isCorrect = userInput === correctAnswerText;
                }
                
                results[key] = {
                    user_input: userInput,
                    correct_answer: correctAnswerText,
                    is_correct: isCorrect
                };
                
                // Log each result
                const style = key.replace('user_', '');
                console.log(`${style.toUpperCase()}:`);
                console.log(`  Your answer: "${userInput}"`);
                console.log(`  Correct answer: "${correctAnswerText}"`);
                console.log(`  Result: ${isCorrect ? '✅ CORRECT' : '❌ INCORRECT'}`);
                console.log('---');
                
                if (!isCorrect) {
                    allCorrect = false;
                }
            }
            
            console.log(`Overall Result: ${allCorrect ? '🎉 ALL CORRECT!' : '📝 Some answers need work'}`);
            console.log('=============================');

            // Update the UI with results
            const resultsContainer = document.querySelector('.results-container');
            if (!resultsContainer) {
                console.error('Results container not found!');
                return;
            }
            resultsContainer.style.display = 'block'; // Ensure it's visible
            resultsContainer.innerHTML = ''; // Clear previous results
            
            // Change panel color based on results
            const panel = document.querySelector('.panel');
            if (panel) {
                // Remove any existing color classes
                panel.classList.remove('waiting', 'correct', 'incorrect');
                
                if (allCorrect) {
                    panel.classList.add('correct'); // Green for all correct
                } else {
                    panel.classList.add('incorrect'); // Red for some incorrect
                }
            }
            
            // Create a single unified results box
            const unifiedResultsBox = document.createElement('div');
            unifiedResultsBox.className = 'unified-results';
            
            // Build the content for the unified box (removed overall-status div)
            let resultsHTML = '<div class="results-list">';
            
            // Add individual results to the same container
            for (const [style, result] of Object.entries(results)) {
                // Skip if the correct answer is empty or just a dash (like katakana when not available)
                if (!result.correct_answer || result.correct_answer === '–' || result.correct_answer.trim() === '') {
                    continue;
                }
                
                // Clean style name for display with user-friendly labels
                const styleName = getFriendlyStyleName(style.replace('user_', ''));
                
                resultsHTML += `
                    <div class="result-item ${result.is_correct ? 'correct' : 'incorrect'}">
                        <span class="style-name">${styleName}</span>
                        <span class="result-status">${result.is_correct ? '✓' : '✗'}</span>
                        <span class="user-answer">Your answer: <code>${result.user_input || '(empty)'}</code></span>
                        ${!result.is_correct ? `<span class="correct-answer">Correct: <code>${result.correct_answer}</code></span>` : ''}
                    </div>
                `;
            }
            
            resultsHTML += '</div>';
            unifiedResultsBox.innerHTML = resultsHTML;
            resultsContainer.appendChild(unifiedResultsBox);

            resultsShown = true; // Set flag to true after showing results
            updateButton(); // Update button text and style
        });
    }

    function resetOrNext() {
        console.log('Moving to next question');
        // Reset panel color before navigating
        resetPanelColor();
        // Navigate to next question instead of just resetting inputs
        window.location.href = "{{ url_for('module1.module1_index') }}";
    }

    // Attach the function to the button click
    const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
    if (button) {
        button.onclick = handleCheckAnswers;
        // Initialize button state
        updateButton();
    } else {
        console.error('Button not found!');
    }

    // Add event listener for the "Enter" key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            handleCheckAnswers(event); // Call the handleCheckAnswers function
        }
    });
});

// Setup real-time conversion for hiragana input
document.addEventListener('DOMContentLoaded', function() {
	const hiraganaRomajiInput = document.getElementById('user_hiragana_romaji');
	const checkingStyles = {{ settings.checking_styles | tojson }};
	const hasHiraganaChecking = checkingStyles.includes('hiragana');

	
	if (hiraganaRomajiInput) {
		// console.log('Test conversion: ka =', convertRomajiToHiragana('ka'));
		
		hiraganaRomajiInput.addEventListener('input', function(e) {
			// Only convert if hiragana checking is enabled
			if (!hasHiraganaChecking) {
				return;
			}
			
			// Clear any existing timeout
			if (window.conversionTimeout) {
				clearTimeout(window.conversionTimeout);
			}
			
			// Set a short delay before converting to allow for complete syllable input
			window.conversionTimeout = setTimeout(() => {
				const cursorPos = e.target.selectionStart;
				const originalValue = e.target.value;
				const convertedValue = convertRomajiToHiragana(originalValue);
				
				if (convertedValue !== originalValue) {
					e.target.value = convertedValue;
					
					// Try to maintain cursor position
					const newCursorPos = Math.min(cursorPos, convertedValue.length);
					setTimeout(() => {
						e.target.setSelectionRange(newCursorPos, newCursorPos);
					}, 0);
				}
			}, 300); // 300ms delay - adjust as needed
		});
	}
});
</script>
{% endblock %}


