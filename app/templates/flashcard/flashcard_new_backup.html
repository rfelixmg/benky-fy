{% extends 'base.html' %}
{% block title %}{{ module_name|title }} | Benky-Fy{% endblock %}
{% block content %}
<meta name="user-authenticated" content="{% if current_user %}true{% else %}false{% endif %}">
<div class="flashcard-container">
	<section class="flashcard-module">
		<button class="settings-toggle-btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
		<header class="flashcard-header">
			<h1>{{ module_name|title }} Flashcards</h1>
		</header>
	
	<!-- Floating Settings Modal -->
	<div class="settings-modal" id="settingsModal">
		<div class="settings-modal-content">
			<div class="settings-modal-header">
				<h2>Settings</h2>
				<button class="settings-close-btn" onclick="toggleSettings()" title="Close">‚úï</button>
			</div>
			<div class="settings-body">
				<!-- Flashcard Display Mode Section -->
				<div class="settings-section">
					<div class="settings-section-header" onclick="toggleSection('flashcard-display')">
						<h3>Flashcard Display Mode</h3>
						<span class="section-toggle">‚ñº</span>
					</div>
					<div class="settings-section-content" id="flashcard-display">
						<div class="radio-group">
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kana" checked onchange="handleDisplayModeChange('kana')">
								<span>Kana</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kanji" onchange="handleDisplayModeChange('kanji')">
								<span>Kanji</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kanji_furigana" onchange="handleDisplayModeChange('kanji_furigana')">
								<span>Kanji + Furigana</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="english" onchange="handleDisplayModeChange('english')">
								<span>English</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="weighted" onchange="handleDisplayModeChange('weighted')">
								<span>üîÑ Weighted Display</span>
							</label>
						</div>
						
						<!-- Kana Sub-toggle -->
						<div class="kana-toggle-panel" id="kana-toggle-panel" style="display: block;">
							<h4>Kana Type</h4>
							<div class="radio-group kana-sub-group">
								<label class="radio-option">
									<input type="radio" name="kana_type" value="hiragana" checked onchange="handleKanaTypeChange('hiragana')">
									<span>Hiragana</span>
								</label>
								<label class="radio-option">
									<input type="radio" name="kana_type" value="katakana" onchange="handleKanaTypeChange('katakana')">
									<span>Katakana</span>
								</label>
							</div>
						</div>
						
						<!-- Furigana Style Sub-panel (for Kanji + Furigana) -->
						<div class="weighted-panel" id="furigana-style-panel" style="display: none;">
							<h4>Furigana Style</h4>
						<label class="select-label">
								<span>Furigana Style</span>
								<select id="furigana-style" onchange="handleFuriganaStyleChange(this.value)">
									<option value="hover">Hover (tooltip on kanji)</option>
									<option value="inline">Inline (above or beside)</option>
									<option value="brackets">Brackets (e.g., È£ü[„Åü]„Åπ„Çã)</option>
									<option value="ruby" selected>Ruby (default browser <ruby>)</option>
							</select>
						</label>
						</div>
						
						<!-- Weighted Display Sub-panel -->
						<div class="weighted-panel" id="weighted-panel" style="display: none;">
							<h4>Display Weights</h4>
							<div class="slider-group">
								<label class="slider-label">
									<span>Kana</span>
									<input type="range" min="0" max="1" step="0.1" value="0.3" class="weight-slider" data-type="kana">
									<span class="slider-value">0.3</span>
								</label>
								<label class="slider-label">
									<span>Kanji</span>
									<input type="range" min="0" max="1" step="0.1" value="0.3" class="weight-slider" data-type="kanji">
									<span class="slider-value">0.3</span>
								</label>
								<label class="slider-label">
									<span>Kanji + Furigana</span>
									<input type="range" min="0" max="1" step="0.1" value="0.2" class="weight-slider" data-type="kanji_furigana">
									<span class="slider-value">0.2</span>
								</label>
								<label class="slider-label">
									<span>English</span>
									<input type="range" min="0" max="1" step="0.1" value="0.2" class="weight-slider" data-type="english">
									<span class="slider-value">0.2</span>
						</label>
							</div>
						</div>
					</div>
				</div>

				<!-- Answer Input Mode Section -->
				<div class="settings-section">
					<div class="settings-section-header" onclick="toggleSection('answer-input')">
						<h3>Answer Input Mode</h3>
						<span class="section-toggle">‚ñº</span>
					</div>
					<div class="settings-section-content" id="answer-input">
						<div class="checkbox-group">
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="hiragana" checked onchange="handleInputModeChange()">
								<span>Hiragana (romaji input ‚Üí auto-converts to kana)</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="romaji" onchange="handleInputModeChange()">
								<span>Romaji (as typed)</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="katakana" onchange="handleInputModeChange()">
								<span>Katakana</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="kanji" onchange="handleInputModeChange()">
								<span>Kanji</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="english" onchange="handleInputModeChange()">
								<span>English</span>
						</label>
						</div>
						<div class="helper-text">
							<p>You can select more than one. Your answer will be accepted if it matches any selected type.</p>
						</div>
					</div>
				</div>

				
				<div class="settings-actions">
					<button type="button" class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
					<button type="button" class="btn btn-secondary" onclick="resetToDefaults()">Reset to Defaults</button>
				</div>
			</div>
		</div>
	</div>
	
		<div class="flashcard-content">
			<div class="prompt-section">
				<p class="prompt-label">Prompt (<span id="prompt-script">{{ item.prompt_script }}</span>)</p>
				<div class="prompt-value" id="prompt-display">
					{% if item.prompt_script == 'kanji' and settings.show_furigana %}
						{% if settings.furigana_style == 'html' and item.furigana_html %}
							<div class="kanji-with-furigana">{{ item.furigana_html|safe }}</div>
						{% elif settings.furigana_style == 'text' and item.furigana_text %}
							<div class="kanji-with-furigana-text">{{ item.furigana_text }}</div>
						{% else %}
							<div class="kanji">{{ item.prompt }}</div>
						{% endif %}
					{% else %}
						<div class="prompt-text">{{ item.prompt }}</div>
					{% endif %}
				</div>
				{% if item.fallback_used %}
					<div class="fallback-notice" style="font-size: 0.8em; color: #666; margin-top: 5px;">
						‚ö†Ô∏è Fallback content used
					</div>
				{% endif %}
			</div>
			
			<div class="answer-section">
				{% set input_modes = settings.get('input_modes', settings.get('checking_styles', ['hiragana'])) %}
				
				{% for mode in input_modes %}
				<div class="input-group">
					{% if mode == 'hiragana' %}
					<label for="user_hiragana" class="input-label">
						Type in romaji (auto-converts to hiragana)
					</label>
					<input type="text" 
						   id="user_hiragana" 
						   name="user_hiragana" 
						   class="answer-input" 
						   placeholder="Type in romaji..." 
						   autofocus 
						   autocomplete="off" 
						   autocorrect="off" 
						   autocapitalize="off" 
						   spellcheck="false" />
					{% elif mode == 'romaji' %}
					<label for="user_romaji" class="input-label">
						Type in romaji
					</label>
					<input type="text" 
						   id="user_romaji" 
						   name="user_romaji" 
						   class="answer-input" 
						   placeholder="Type in romaji..." 
						   autocomplete="off" 
						   autocorrect="off" 
						   autocapitalize="off" 
						   spellcheck="false" />
					{% else %}
					<label for="user_{{ mode }}" class="input-label">Your answer ({{ mode }}):</label>
					<input type="text" 
						   id="user_{{ mode }}" 
						   name="user_{{ mode }}" 
						   class="answer-input" 
						   placeholder="Type {{ mode }}..." 
						   autocomplete="off" 
						   autocorrect="off" 
						   autocapitalize="off" 
						   spellcheck="false" />
					{% endif %}
				</div>
				{% endfor %}
			</div>
			
			<input type="hidden" id="item_id" name="item_id" value="{{ item.index }}">

			<div class="actions-section">
				<button type="button" class="check-button" id="checkButton" onclick="handleCheckAnswers()" disabled>Check Answer</button>
				<div class="branding-tooltip">powered by Benky-fy</div>
				<div class="feedback-message" id="feedbackMessage" style="display: none;"></div>
			</div>
		
		<!-- Always render the results container -->
		<div class="results-container">
			<!-- Initial content can be empty or a placeholder -->
		</div>

		{% if results is not none %}
		<div class="overall-result {{ 'correct' if all_correct else 'incorrect' }}">
			<p><strong>{{ 'All Correct!' if all_correct else 'Some Incorrect' }}</strong></p>
		</div>
			
		{% for style, result in results.items() %}
		<div class="result {{ 'correct' if result.is_correct else 'incorrect' }}">
			<h4>{{ style.title() }}</h4>
			<p>Your answer: <code>{{ result.user_input or '(empty)' }}</code></p>
			<p>Correct answer: <code>{{ result.correct_answer }}</code></p>
			<p class="result-status">{{ '‚úì Correct' if result.is_correct else '‚úó Incorrect' }}</p>
		</div>
		{% endfor %}

		<button class="btn" onclick="goToNext()">
			Next ‚û°Ô∏è
		</button>

		{% endif %}
		</div>
	</section>
</div>

<script src="{{ url_for('static', filename='js/utils.js') }}"></script>

<script>
// Template variables
const templateSettings = {
	inputModes: ["hiragana"],
	checkingStyles: ["hiragana"] // fallback for compatibility
};
</script>

<script>
// Settings management
function toggleSettings() {
	const settingsModal = document.getElementById('settingsModal');
	if (settingsModal) {
		settingsModal.classList.toggle('show');
	}
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
	const settingsModal = document.getElementById('settingsModal');
	const settingsModalContent = document.querySelector('.settings-modal-content');
	
	if (settingsModal && settingsModal.classList.contains('show')) {
		if (!settingsModalContent.contains(event.target) && !event.target.closest('.settings-toggle-btn')) {
			settingsModal.classList.remove('show');
		}
	}
});

// Settings state management
let settingsState = {
	displayMode: 'kana',
	kanaTypes: ['hiragana'],
	inputModes: ['hiragana'],
	furiganaStyle: 'ruby',
	weights: {
		kana: 0.3,
		kanji: 0.3,
		kanji_furigana: 0.2,
		english: 0.2
	}
};

// Track user interactions to prevent API calls on page load
let isUserInteraction = false;
let isPageLoaded = false;

// Collapsible section management
function toggleSection(sectionId) {
	const content = document.getElementById(sectionId);
	const header = content.previousElementSibling;
	const toggle = header.querySelector('.section-toggle');
	
	if (content.style.display === 'none' || content.style.display === '') {
		content.style.display = 'block';
		toggle.textContent = '‚ñ≤';
		header.classList.add('expanded');
	} else {
		content.style.display = 'none';
		toggle.textContent = '‚ñº';
		header.classList.remove('expanded');
	}
}

// Display mode change handler
function handleDisplayModeChange(mode) {
	settingsState.displayMode = mode;
	const weightedPanel = document.getElementById('weighted-panel');
	const kanaTogglePanel = document.getElementById('kana-toggle-panel');
	const furiganaStylePanel = document.getElementById('furigana-style-panel');
	
	if (mode === 'weighted') {
		weightedPanel.style.display = 'block';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'block';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kanji_furigana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'block';
	} else {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	}
	
	// Update live preview if present
	updateLivePreview();
}

// Kana types change handler (multi-select)
function handleKanaTypesChange() {
	const kanaCheckboxes = document.querySelectorAll('input[name="kana_types"]:checked');
	settingsState.kanaTypes = Array.from(kanaCheckboxes).map(cb => cb.value);
	// In the future, alternate or randomize if both are selected
	updateLivePreview();
}

// Furigana style change handler
function handleFuriganaStyleChange(style) {
	isUserInteraction = true;
	settingsState.furiganaStyle = style;
	updateLivePreview();
}

// Input mode change handler
function handleInputModeChange() {
	const checkboxes = document.querySelectorAll('input[name="input_modes"]:checked');
	settingsState.inputModes = Array.from(checkboxes).map(cb => cb.value);
	
	// Update input fields immediately
	updateInputFields();
	
	// Update check button state
	updateCheckButtonState();
	
	// Update live preview if present
	updateLivePreview();
}

// Update check button state based on input modes
function updateCheckButtonState() {
	const checkButton = document.getElementById('checkButton');
	if (checkButton) {
		checkButton.disabled = settingsState.inputModes.length === 0;
	}
}

// Update input fields based on current settings
function updateInputFields() {
	try {
		const answerSection = document.querySelector('.answer-section');
		if (!answerSection) {
			console.warn('Answer section not found, skipping input field update');
			return;
		}
	
	// Clear existing input fields
	const existingInputs = answerSection.querySelectorAll('.input-group');
	existingInputs.forEach(input => input.remove());
	
	// Create new input fields based on current settings
	const inputModes = settingsState.inputModes || ['hiragana'];
	
	inputModes.forEach((mode, index) => {
		const inputGroup = document.createElement('div');
		inputGroup.className = 'input-group';
		
		let label, input;
		
		if (mode === 'hiragana') {
			label = document.createElement('label');
			label.className = 'input-label';
			label.setAttribute('for', 'user_hiragana');
			label.textContent = 'Type in romaji (auto-converts to hiragana)';
			
			input = document.createElement('input');
			input.type = 'text';
			input.id = 'user_hiragana';
			input.name = 'user_hiragana';
			input.className = 'answer-input';
			input.placeholder = 'Type in romaji...';
			if (index === 0) input.autofocus = true;
		} else if (mode === 'romaji') {
			label = document.createElement('label');
			label.className = 'input-label';
			label.setAttribute('for', 'user_romaji');
			label.textContent = 'Type in romaji';
			
			input = document.createElement('input');
			input.type = 'text';
			input.id = 'user_romaji';
			input.name = 'user_romaji';
			input.className = 'answer-input';
			input.placeholder = 'Type in romaji...';
			if (index === 0) input.autofocus = true;
		} else {
			label = document.createElement('label');
			label.className = 'input-label';
			label.setAttribute('for', `user_${mode}`);
			label.textContent = `Your answer (${mode}):`;
			
			input = document.createElement('input');
			input.type = 'text';
			input.id = `user_${mode}`;
			input.name = `user_${mode}`;
			input.className = 'answer-input';
			input.placeholder = `Type ${mode}...`;
			if (index === 0) input.autofocus = true;
		}
		
		// Add common attributes
		input.autocomplete = 'off';
		input.autocorrect = 'off';
		input.autocapitalize = 'off';
		input.spellcheck = false;
		
		inputGroup.appendChild(label);
		inputGroup.appendChild(input);
		answerSection.appendChild(inputGroup);
	});
	
	// Re-initialize input monitoring
	const newInputElements = document.querySelectorAll('.answer-input');
	newInputElements.forEach(input => {
		input.addEventListener('input', function() {
			const btn = document.getElementById('checkButton');
			if (btn) {
				const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
				btn.disabled = !hasInput;
			}
		});
		input.addEventListener('keyup', function() {
			const btn = document.getElementById('checkButton');
			if (btn) {
				const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
				btn.disabled = !hasInput;
			}
		});
	});
	
	// Re-initialize Romaji conversion for hiragana field
	const hiraganaInput = document.getElementById('user_hiragana');
	if (hiraganaInput) {
		hiraganaInput.addEventListener('input', function(e) {
			if (!settingsState.inputModes.includes('hiragana')) return;
			
			if (window.conversionTimeout) {
				clearTimeout(window.conversionTimeout);
			}
			
			window.conversionTimeout = setTimeout(() => {
				const cursorPos = e.target.selectionStart;
				const originalValue = e.target.value;
				const convertedValue = convertRomajiToHiragana(originalValue);
				
				if (convertedValue !== originalValue) {
					e.target.value = convertedValue;
					const newCursorPos = Math.min(cursorPos, convertedValue.length);
					setTimeout(() => {
						e.target.setSelectionRange(newCursorPos, newCursorPos);
					}, 0);
				}
			}, 300);
		});
	}
	
	// Update button state
	const btn = document.getElementById('checkButton');
	if (btn) {
		const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
		btn.disabled = !hasInput;
	}
	
	} catch (error) {
		console.error('Error updating input fields:', error);
	}
}


// Weight slider change handler
function handleWeightChange(slider) {
	isUserInteraction = true;
	const type = slider.dataset.type;
	const value = parseFloat(slider.value);
	
	settingsState.weights[type] = value;
	
	// Update the displayed value
	const valueSpan = slider.parentElement.querySelector('.slider-value');
	valueSpan.textContent = value.toFixed(1);
	
	// Update live preview if present
	updateLivePreview();
	
	// Update display text if in weighted mode
	const currentMode = document.querySelector('input[name="display_mode"]:checked')?.value;
	if (currentMode === 'weighted') {
		updateDisplayText();
	}
}

// Live preview update (placeholder for future implementation)
function updateLivePreview() {
	// This would update a live preview of the flashcard display
	// For now, just log the current state
	console.log('Settings updated:', settingsState);
}

// Check if user is authenticated
function checkAuthenticationStatus() {
	// Check for common authentication indicators
	const hasUserSession = document.querySelector('meta[name="user-authenticated"]')?.content === 'true';
	const hasAuthCookie = document.cookie.includes('session=') || document.cookie.includes('flask-session=');
	const isOnAuthPage = window.location.pathname.includes('/auth/') || window.location.pathname.includes('/login');
	
	// If we're on an auth page, definitely not authenticated
	if (isOnAuthPage) {
		return false;
	}
	
	// If we have explicit session indicators, we're authenticated
	if (hasUserSession || hasAuthCookie) {
		return true;
	}
	
	// Default to false for safety
	return false;
}

// Enhanced display text handler with full backend integration
function updateDisplayText() {
	const itemId = document.querySelector('input[name="item_id"]')?.value;
	if (!itemId) {
		console.log('No item_id found, skipping display text update');
		return;
	}
	
	// Get current settings from the form
	const displayMode = document.querySelector('input[name="display_mode"]:checked')?.value || 'kana';
	const kanaType = document.querySelector('input[name="kana_type"]:checked')?.value || 'hiragana';
	const furiganaStyle = document.getElementById('furigana-style')?.value || 'ruby';
	
	// Build settings object with all current settings
	const settings = {
		display_mode: displayMode,
		kana_type: kanaType,
		furigana_style: furiganaStyle,
		proportions: getCurrentProportions()
	};
	
	// Send request to get display text with settings as URL parameters
	const params = new URLSearchParams({
		item_id: itemId,
		display_mode: displayMode,
		kana_type: kanaType,
		furigana_style: furiganaStyle
	});
	
	// Add proportions if available
	const proportions = getCurrentProportions();
	Object.keys(proportions).forEach(key => {
		params.append(`proportions.${key}`, proportions[key]);
	});
	
	fetch(`/begginer/{{ module_name }}/api/display-text?${params}`, {
		method: 'GET',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		if (response.status === 401 || response.status === 403) {
			// Authentication required, use test endpoint for development
			console.log('Auth required, using test endpoint');
			const testParams = new URLSearchParams({
				item_id: itemId,
				display_mode: displayMode,
				kana_type: kanaType,
				furigana_style: furiganaStyle
			});
			return fetch(`/begginer/{{ module_name }}/api/test-display-text?${testParams}`);
		}
		return response;
	})
	.then(response => response.json())
	.then(data => {
		if (data.error) {
			console.error('Error getting display text:', data.error);
			showDisplayError('Failed to load display text');
			return;
		}
		
		// Update the prompt display with enhanced rendering
		updatePromptDisplay(data, settings);
		
		// Log display constraints for debugging
		console.log('Display updated:', {
			mode: data.mode,
			script: data.script,
			text: data.text,
			fallback_used: data.fallback_used,
			settings: settings
		});
	})
	.catch(error => {
		console.error('Error updating display text:', error);
		showDisplayError('Network error loading display text');
	});
}

// Enhanced prompt display update with proper styling and fallbacks
function updatePromptDisplay(data, settings) {
	const promptDisplay = document.getElementById('prompt-display');
	const promptScript = document.getElementById('prompt-script');
	const fallbackNotice = document.querySelector('.fallback-notice');
	
	if (!promptDisplay || !promptScript) {
		console.error('Required DOM elements not found');
		return;
	}
	
	// Clear existing content
	promptDisplay.innerHTML = '';
	
	// Handle "N/A" fallback case
	if (data.text === "N/A" || data.script === "error") {
		showDisplayError('Content not available for this display mode');
		return;
	}
	
	// Create appropriate display element based on script type and settings
	let displayElement = createDisplayElement(data, settings);
	promptDisplay.appendChild(displayElement);
	
	// Update script indicator
	promptScript.textContent = data.script;
	
	// Show/hide fallback notice
	if (fallbackNotice) {
		fallbackNotice.style.display = data.fallback_used ? 'block' : 'none';
	}
}

// Create display element with proper styling and furigana handling
function createDisplayElement(data, settings) {
	const displayElement = document.createElement('div');
	
	// Apply base styling based on script type
	switch (data.script) {
		case 'kanji_furigana':
			displayElement.className = 'kanji-with-furigana';
			// Handle different furigana styles
			applyFuriganaStyle(displayElement, data.text, settings.furigana_style);
			break;
			
		case 'kanji':
			displayElement.className = 'kanji';
			displayElement.textContent = data.text;
			break;
			
		case 'hiragana':
		case 'katakana':
			displayElement.className = 'prompt-text';
			displayElement.textContent = data.text;
			// Add script-specific styling
			displayElement.setAttribute('data-script', data.script);
			break;
			
		case 'english':
			displayElement.className = 'prompt-text english-text';
			displayElement.textContent = data.text;
			break;
			
		default:
			displayElement.className = 'prompt-text';
			displayElement.textContent = data.text;
	}
	
	return displayElement;
}

// Apply furigana styling based on user preference
function applyFuriganaStyle(element, text, furiganaStyle) {
	switch (furiganaStyle) {
		case 'ruby':
			// Default HTML ruby tags (backend provides this)
			element.innerHTML = text;
			break;
			
		case 'brackets':
			// Convert ruby tags to bracket format: È£ü[„Åü]„Åπ„Çã
			element.innerHTML = convertRubyToBrackets(text);
			break;
			
		case 'hover':
			// Convert to hover tooltip format
			element.innerHTML = convertRubyToHover(text);
			break;
			
		case 'inline':
			// Convert to inline format: „Åü„Åπ„Çã (È£ü)
			element.innerHTML = convertRubyToInline(text);
			break;
			
		default:
			// Fallback to ruby
			element.innerHTML = text;
	}
}

// Convert ruby tags to bracket format
function convertRubyToBrackets(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, '$1[$2]');
}

// Convert ruby tags to hover tooltip format
function convertRubyToHover(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, 
		'<span class="kanji-hover" title="$2">$1</span>');
}

// Convert ruby tags to inline format
function convertRubyToInline(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, '$2 ($1)');
}

// Show display error message
function showDisplayError(message) {
	const promptDisplay = document.getElementById('prompt-display');
	if (promptDisplay) {
		promptDisplay.innerHTML = `
			<div class="display-error">
				<span class="error-icon">‚ö†Ô∏è</span>
				<span class="error-message">${message}</span>
			</div>
		`;
	}
}

// Get current proportions from sliders
function getCurrentProportions() {
	const proportions = {};
	const sliders = document.querySelectorAll('.slider-group input[type="range"]');
	sliders.forEach(slider => {
		const type = slider.getAttribute('data-type');
		if (type) {
			proportions[type] = parseFloat(slider.value);
		}
	});
	return proportions;
}

// Enhanced display mode change handler with live preview
function handleDisplayModeChange(mode) {
	// Mark as user interaction
	isUserInteraction = true;
	
	settingsState.displayMode = mode;
	const weightedPanel = document.getElementById('weighted-panel');
	const kanaTogglePanel = document.getElementById('kana-toggle-panel');
	const furiganaStylePanel = document.getElementById('furigana-style-panel');
	
	if (mode === 'weighted') {
		weightedPanel.style.display = 'block';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'block';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kanji_furigana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'block';
	} else {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	}
	
	// Update display text with new constraints
	updateDisplayText();
}

// Force display text update (for user interactions)
function forceUpdateDisplayText() {
	console.log('Force updating display text...');
	updateDisplayText();
}

// Kana type change handler
function handleKanaTypeChange(type) {
	isUserInteraction = true;
	settingsState.kanaTypes = [type];
	
	// Update display text if in kana mode
	const currentMode = document.querySelector('input[name="display_mode"]:checked')?.value;
	if (currentMode === 'kana') {
		updateDisplayText();
	}
}

// Save settings and update input fields
function saveSettings() {
	try {
		console.log('Saving settings:', settingsState);
		
		// Prepare settings data for backend API
		const formData = new FormData();
		formData.append('flashcard_type', 'translation');
		formData.append('display_mode', settingsState.displayMode);
		formData.append('kana_type', settingsState.kanaTypes[0] || 'hiragana');
		formData.append('furigana_style', settingsState.furiganaStyle);
		
		// Add each input mode as separate field
		settingsState.inputModes.forEach(mode => {
			formData.append('input_modes', mode);
		});
		
		// Add proportions
		Object.keys(settingsState.weights).forEach(key => {
			formData.append(`proportion_${key}`, settingsState.weights[key]);
		});
		
		// Call backend API to save settings
		fetch(`/begginer/{{ module_name }}/settings`, {
			method: 'POST',
			body: formData,
			redirect: 'manual' // Prevent automatic redirect following
		})
		.then(response => {
			if (response.status === 401 || response.status === 403 || response.status === 302) {
				// Authentication required or redirect to login, use test endpoint for development
				console.log('Auth required, using test endpoint');
				return fetch(`/begginer/{{ module_name }}/api/test-settings`, {
					method: 'POST',
					body: formData
				}).then(testResponse => testResponse.json());
			}
			if (!response.ok) {
				throw new Error(`HTTP error! status: ${response.status}`);
			}
			return response.json();
		})
		.then(data => {
			console.log('Settings saved to backend:', data);
			
			// Also store in localStorage as backup
			localStorage.setItem('flashcardSettings', JSON.stringify(settingsState));
			console.log('Settings saved to localStorage as backup');
			
			// Update input fields based on current settings
			updateInputFields();
			console.log('Input fields updated');
			
			// Show success feedback
			const saveButton = document.querySelector('.btn-primary');
			if (saveButton) {
				const originalText = saveButton.textContent;
				saveButton.textContent = 'Saved!';
				saveButton.style.backgroundColor = '#10b981';
				
				setTimeout(() => {
					saveButton.textContent = originalText;
					saveButton.style.backgroundColor = '';
				}, 2000);
			}
			
			// Close modal
			toggleSettings();
			console.log('Settings saved successfully');
		})
		.catch(error => {
			console.error('Error saving settings to backend:', error);
			
			// Fallback to localStorage only
			localStorage.setItem('flashcardSettings', JSON.stringify(settingsState));
			console.log('Settings saved to localStorage only (backend failed)');
			
			// Update input fields
			updateInputFields();
			
			// Show error feedback
			const saveButton = document.querySelector('.btn-primary');
			if (saveButton) {
				const originalText = saveButton.textContent;
				saveButton.textContent = 'Saved (Local Only)';
				saveButton.style.backgroundColor = '#f59e0b';
				
				setTimeout(() => {
					saveButton.textContent = originalText;
					saveButton.style.backgroundColor = '';
				}, 2000);
			}
			
			// Close modal
			toggleSettings();
		});
		
	} catch (error) {
		console.error('Error saving settings:', error);
		alert('Error saving settings: ' + error.message);
	}
}

// Load settings from localStorage (backend settings are loaded via template)
function loadSettings() {
	// Load from localStorage since backend settings are provided via template
	const saved = localStorage.getItem('flashcardSettings');
	if (saved) {
		try {
			settingsState = { ...settingsState, ...JSON.parse(saved) };
			applySettingsToUI();
			console.log('Settings loaded from localStorage');
		} catch (parseError) {
			console.error('Error parsing localStorage settings:', parseError);
			console.log('Using default settings');
		}
	} else {
		console.log('No saved settings found, using defaults');
	}
}

// Apply loaded settings to UI
function applySettingsToUI() {
	// Apply display mode
	const displayRadios = document.querySelectorAll('input[name="display_mode"]');
	displayRadios.forEach(radio => {
		if (radio.value === settingsState.displayMode) {
			radio.checked = true;
			handleDisplayModeChange(settingsState.displayMode);
		}
	});
	
	// Apply kana types (checkboxes)
	const kanaCheckboxesAll = document.querySelectorAll('input[name="kana_types"]');
	kanaCheckboxesAll.forEach(cb => {
		cb.checked = settingsState.kanaTypes.includes(cb.value);
	});
	
	// Apply input modes
	const inputCheckboxes = document.querySelectorAll('input[name="input_modes"]');
	inputCheckboxes.forEach(checkbox => {
		checkbox.checked = settingsState.inputModes.includes(checkbox.value);
	});
	
	// CRITICAL: Update input fields based on selected modes
	updateInputFields();
	
	// Apply furigana style
	const furiganaStyleSelect = document.getElementById('furigana-style');
	if (furiganaStyleSelect) {
		furiganaStyleSelect.value = settingsState.furiganaStyle;
	}
	
	// Apply weights
	Object.keys(settingsState.weights).forEach(type => {
		const slider = document.querySelector(`[data-type="${type}"]`);
		if (slider) {
			slider.value = settingsState.weights[type];
			const valueSpan = slider.parentElement.querySelector('.slider-value');
			valueSpan.textContent = settingsState.weights[type].toFixed(1);
		}
	});
	
	// Update check button state
	updateCheckButtonState();
	
	// Update input fields based on loaded settings
	updateInputFields();
}

function resetToDefaults() {
	if (confirm('Are you sure you want to reset all settings to their default values?')) {
		// Reset to default state
		settingsState = {
			displayMode: 'kana',
			kanaTypes: ['hiragana'],
			inputModes: ['hiragana'],
			furiganaStyle: 'ruby',
			weights: {
				kana: 0.3,
				kanji: 0.3,
				kanji_furigana: 0.2,
				english: 0.2
			}
		};
		
		// Apply defaults to UI
		applySettingsToUI();
		
		// Clear localStorage
		localStorage.removeItem('flashcardSettings');
		
		// Show feedback
		const resetButton = document.querySelector('.btn-secondary');
		const originalText = resetButton.textContent;
		resetButton.textContent = 'Reset!';
		resetButton.style.backgroundColor = '#f59e0b';
		
		setTimeout(() => {
			resetButton.textContent = originalText;
			resetButton.style.backgroundColor = '';
		}, 2000);
	}
}

// Initialize settings on page load
document.addEventListener('DOMContentLoaded', function() {
	// Mark page as loaded
	isPageLoaded = true;
	
	// Load saved settings
	loadSettings();
	
	// Sync JavaScript state with HTML checkboxes (in case HTML has different defaults)
	const checkedInputModes = Array.from(document.querySelectorAll('input[name="input_modes"]:checked')).map(cb => cb.value);
	if (checkedInputModes.length > 0) {
		settingsState.inputModes = checkedInputModes;
	}
	
	// Ensure input fields are created based on current settings
	updateInputFields();
	
	// Add event listeners for weight sliders
	const weightSliders = document.querySelectorAll('.weight-slider');
	weightSliders.forEach(slider => {
		slider.addEventListener('input', function() {
			handleWeightChange(this);
		});
	});
	
	// Initialize all sections as collapsed
	const sections = ['flashcard-display', 'answer-input'];
	sections.forEach(sectionId => {
		const content = document.getElementById(sectionId);
		if (content) {
			content.style.display = 'none';
		}
	});
});

// Rest of the existing JavaScript functions...
function checkEnglishAnswer(userInput, correctAnswersText) {
    /**
     * Enhanced English answer checking that handles multiple formats:
     * 1. Multiple meanings separated by " / " (e.g., "simple / easy")
     * 2. Comma-separated meanings (e.g., "tough, serious")
     * 3. Verb variations with/without "to" (e.g., "to look" accepts "look")
     * 4. Flexible matching for common variations
     */
    if (!userInput) {
        return false;
    }
    
    // First, try the original " / " format
    if (correctAnswersText.includes(" / ")) {
        const correctAnswers = correctAnswersText.split(" / ").map(answer => answer.trim().toLowerCase());
        if (correctAnswers.includes(userInput)) {
            return true;
        }
    }
    
    // Handle comma-separated meanings (e.g., "tough, serious")
    if (correctAnswersText.includes(",") && !correctAnswersText.includes(" / ")) {
        const correctAnswers = correctAnswersText.split(",").map(answer => answer.trim().toLowerCase());
        if (correctAnswers.includes(userInput)) {
            return true;
        }
    }
    
    // Handle verb variations (with/without "to")
    // Check if the correct answer starts with "to " and user input doesn't
    if (correctAnswersText.toLowerCase().startsWith("to ")) {
        const verbWithoutTo = correctAnswersText.substring(3).trim().toLowerCase(); // Remove "to " prefix
        if (userInput === verbWithoutTo) {
            return true;
        }
    }
    
    // Check if user input starts with "to " but correct answer doesn't
    if (userInput.startsWith("to ")) {
        const verbWithoutTo = userInput.substring(3).trim(); // Remove "to " prefix
        if (verbWithoutTo === correctAnswersText.toLowerCase()) {
            return true;
        }
    }
    
    // Handle multiple verb forms in comma-separated format
    if (correctAnswersText.includes(",")) {
        const answers = correctAnswersText.split(",").map(answer => answer.trim().toLowerCase());
        for (const answer of answers) {
            // Check exact match
            if (userInput === answer) {
                return true;
            }
            // Check verb variations
            if (answer.startsWith("to ") && userInput === answer.substring(3).trim()) {
                return true;
            }
            if (userInput.startsWith("to ") && answer === userInput.substring(3).trim()) {
                return true;
            }
        }
    }
    
    // Fallback: exact match (case-insensitive)
    return userInput === correctAnswersText.toLowerCase();
}

function goToNext() {
	window.location.href = "{{ url_for(module_name + '.index') }}";
}

function getFriendlyStyleName(style) {
    const styleMap = {
        'hiragana_romaji': 'Hiragana/Romaji',
        'hiragana': 'Hiragana',
        'romaji': 'Romaji',
        'kanji': 'Kanji',
        'katakana': 'Katakana',
        'english': 'English'
    };
    return styleMap[style] || style.charAt(0).toUpperCase() + style.slice(1);
}

function fetchCorrectAnswers() {
    // Get the item ID from the hidden input
    const itemId = document.getElementById('item_id').value;
    
    // Define the API endpoint with item_id parameter
    const apiUrl = `{{ url_for(module_name + '.get_correct_answers') }}?item_id=${itemId}`;

    // Make the API request
    return fetch(apiUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            // Return the data directly since it's already in the correct format
            return data;
        })
        .catch(error => {
            console.error('Error fetching correct answers:', error);
            return null;
        });
}

document.addEventListener('DOMContentLoaded', function() {
    let resultsShown = false; // Define resultsShown in the correct scope
    let feedbackTimeout = null; // For managing feedback persistence

    // Initialize flashcard module color to waiting state
    const flashcardModule = document.querySelector('.flashcard-module');
    if (flashcardModule) {
        flashcardModule.classList.add('waiting'); // White for waiting answer
    }

    // Initialize button state and input monitoring
    let checkButton = document.getElementById('checkButton');
    
    function updateButtonState() {
        if (checkButton) {
            const inputElements = document.querySelectorAll('.answer-input');
            const hasInput = Array.from(inputElements).some(input => input.value.trim().length > 0);
            checkButton.disabled = !hasInput || resultsShown;
            console.log('Button state updated:', { hasInput, resultsShown, disabled: checkButton.disabled });
        }
    }
    
    // Monitor input changes for all fields
    const inputElements = document.querySelectorAll('.answer-input');
    inputElements.forEach(input => {
        input.addEventListener('input', function() {
            if (checkButton) {
                const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
                checkButton.disabled = !hasInput || resultsShown;
            }
        });
        input.addEventListener('keyup', function() {
            if (checkButton) {
                const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
                checkButton.disabled = !hasInput || resultsShown;
            }
        });
    });
    
    // Initial button state
    if (checkButton) {
        const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
        checkButton.disabled = !hasInput || resultsShown;
    }

    // Mixed Input Feedback System
    function applyMixedInputFeedback(data) {
        const { all_correct, results, input_modes } = data;
        
        // Calculate overall state
        const correctCount = Object.values(results).filter(r => r.is_correct).length;
        const totalCount = Object.keys(results).length;
        const hasMixedResults = correctCount > 0 && correctCount < totalCount;
        
        // Apply individual field colors
        Object.entries(results).forEach(([mode, result]) => {
            const inputElement = document.getElementById(`user_${mode}`);
            if (inputElement) {
                // Remove existing classes
                inputElement.classList.remove('field-correct', 'field-incorrect');
                
                // Add appropriate class
                if (result.is_correct) {
                    inputElement.classList.add('field-correct');
                } else {
                    inputElement.classList.add('field-incorrect');
                }
            }
        });
        
        // Apply overall container state
        const flashcardModuleElement = document.querySelector('.flashcard-module');
        if (flashcardModuleElement) {
            // Remove existing color classes
            flashcardModuleElement.classList.remove('waiting', 'correct', 'incorrect', 'mixed');
            
            if (all_correct) {
                flashcardModuleElement.classList.add('correct'); // Green: Perfect! All correct
            } else if (hasMixedResults) {
                flashcardModuleElement.classList.add('mixed'); // Orange: Great progress! Fix the red fields
            } else {
                flashcardModuleElement.classList.add('incorrect'); // Red: Try again, you've got this!
            }
        }
        
        // Update submit button state
        const checkButton = document.getElementById('checkButton');
        if (checkButton) {
            if (all_correct) {
                checkButton.textContent = 'Perfect! Next ‚û°Ô∏è';
                checkButton.classList.add('success-button');
            } else if (hasMixedResults) {
                checkButton.textContent = 'Great Progress! Next ‚û°Ô∏è';
                checkButton.classList.add('progress-button');
            } else {
                checkButton.textContent = 'Try Again!';
                checkButton.classList.add('retry-button');
            }
        }
        
        // Focus guidance to incorrect fields
        if (hasMixedResults) {
            const firstIncorrectField = Object.entries(results)
                .find(([mode, result]) => !result.is_correct);
            if (firstIncorrectField) {
                const [mode] = firstIncorrectField;
                const inputElement = document.getElementById(`user_${mode}`);
                if (inputElement) {
                    // Add focus indicator
                    inputElement.classList.add('needs-attention');
                    // Scroll to field if needed
                    inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
    }

    function showFeedback(isCorrect, correctAnswer = '') {
        const feedbackMessage = document.getElementById('feedbackMessage');
        if (!feedbackMessage) return;
        
        // Clear any existing timeout
        if (feedbackTimeout) {
            clearTimeout(feedbackTimeout);
        }
        
        // Show feedback
        feedbackMessage.style.display = 'flex';
        feedbackMessage.className = 'feedback-message ' + (isCorrect ? 'correct' : 'incorrect');
        
        if (isCorrect) {
            feedbackMessage.innerHTML = '‚úÖ Correct!';
        } else {
            feedbackMessage.innerHTML = `‚ùå Incorrect. The answer was: <strong>${correctAnswer}</strong>`;
        }
        
        // Auto-hide after 3 seconds
        feedbackTimeout = setTimeout(() => {
            feedbackMessage.style.display = 'none';
        }, 3000);
    }
    
    function hideFeedback() {
        const feedbackMessage = document.getElementById('feedbackMessage');
        if (feedbackMessage) {
            feedbackMessage.style.display = 'none';
        }
        if (feedbackTimeout) {
            clearTimeout(feedbackTimeout);
            feedbackTimeout = null;
        }
    }

    function updateButton() {
        const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
        if (button) {
            if (resultsShown) {
                button.textContent = 'Next ‚û°Ô∏è';
                button.classList.add('next-button');
                button.classList.remove('check-button');
                button.disabled = false;
            } else {
                button.textContent = 'Check Answer';
                button.classList.add('check-button');
                button.classList.remove('next-button');
                // Re-evaluate button state
                const hasInput = Array.from(document.querySelectorAll('.answer-input')).some(input => input.value.trim().length > 0);
                button.disabled = !hasInput || resultsShown;
            }
        }
    }

    function resetPanelColor() {
        const flashcardModuleElement = document.querySelector('.flashcard-module');
        if (flashcardModuleElement) {
            flashcardModuleElement.classList.remove('waiting', 'correct', 'incorrect');
            flashcardModuleElement.classList.add('waiting'); // Reset to white waiting state
        }
    }

    function handleCheckAnswers(event) {
        console.log('handleCheckAnswers called', { event, resultsShown });
        
        if (event) {
            event.preventDefault(); // Prevent default behavior
        }

        if (resultsShown) {
            resetOrNext();
            return;
        }

        // Get current input modes for the request
        const inputModes = settingsState.inputModes || ['hiragana'];
        
        // Retrieve user inputs - send ALL selected input modes (even empty ones)
        const userInputs = {};
        const inputElements = document.querySelectorAll('.answer-input');
        inputElements.forEach(input => {
            userInputs[input.name] = input.value.trim(); // Send all fields, even empty
        });

        // Frontend validation: Check if any input is provided
        const hasAnyInput = Object.values(userInputs).some(value => value.length > 0);
        if (!hasAnyInput) {
            console.log('No input provided - showing validation message');
            showFeedback(false, 'Please provide at least one answer before checking');
            return;
        }

        // Submit to backend for validation
        const itemId = document.getElementById('item_id').value;
        const formData = new FormData();
        formData.append('item_id', itemId);
        formData.append('input_modes', inputModes.join(','));
        
        // CRITICAL: Add ALL selected input modes as form fields (even if empty)
        inputModes.forEach(mode => {
            const fieldName = `user_${mode}`;
            const fieldValue = userInputs[fieldName] || ''; // Use empty string if not found
            formData.append(fieldName, fieldValue);
        });

        // Use test endpoint for development
        fetch('/begginer/{{ module_name }}/api/test-check-answers', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error checking answers:', data.error);
                return;
            }

            const results = data.results || {};
            const allCorrect = data.all_correct || false;
            
            console.log('=== Answer Check Results ===');
            console.log('Backend response:', data);
            
            // Log each result
            for (const [mode, result] of Object.entries(results)) {
                console.log(`${mode.toUpperCase()}:`);
                console.log(`  Your answer: "${result.user_input}"`);
                console.log(`  Correct answer: "${result.correct_answer}"`);
                console.log(`  Result: ${result.is_correct ? '‚úÖ CORRECT' : '‚ùå INCORRECT'}`);
                console.log('---');
            }
            
            console.log(`Overall Result: ${allCorrect ? 'üéâ ALL CORRECT!' : 'üìù Some answers need work'}`);
            console.log('=============================');

            // Hide any existing feedback
            hideFeedback();
            
            // Show feedback message
            const primaryMode = inputModes[0] || 'hiragana';
            const primaryResult = results[primaryMode];
            const correctAnswer = primaryResult ? primaryResult.correct_answer : '';
            
            showFeedback(allCorrect, correctAnswer);
            
            // Update the UI with results
            const resultsContainer = document.querySelector('.results-container');
            if (!resultsContainer) {
                console.error('Results container not found!');
                return;
            }
            resultsContainer.style.display = 'block'; // Ensure it's visible
            resultsContainer.innerHTML = ''; // Clear previous results
            
            // Apply mixed input feedback system
            applyMixedInputFeedback(data);
            
            // Create a single unified results box
            const unifiedResultsBox = document.createElement('div');
            unifiedResultsBox.className = 'unified-results';
            
            // Build the content for the unified box
            let resultsHTML = '<div class="results-list">';
            
            // Add individual results to the same container
            for (const [mode, result] of Object.entries(results)) {
                // Skip if the correct answer is empty or just a dash
                if (!result.correct_answer || result.correct_answer === '‚Äì' || result.correct_answer.trim() === '') {
                    continue;
                }
                
                // Clean mode name for display with user-friendly labels
                const modeName = getFriendlyStyleName(mode);
                
                resultsHTML += `
                    <div class="result-item ${result.is_correct ? 'correct' : 'incorrect'}">
                        <span class="style-name">${modeName}</span>
                        <span class="result-status">${result.is_correct ? '‚úì' : '‚úó'}</span>
                        <span class="user-answer">Your answer: <code>${result.user_input || '(empty)'}</code></span>
                        ${!result.is_correct ? `<span class="correct-answer">Correct: <code>${result.correct_answer}</code></span>` : ''}
                    </div>
                `;
            }
            
            resultsHTML += '</div>';
            unifiedResultsBox.innerHTML = resultsHTML;
            resultsContainer.appendChild(unifiedResultsBox);

            resultsShown = true; // Set flag to true after showing results
            updateButton(); // Update button text and style
        })
        .catch(error => {
            console.error('Error submitting answers:', error);
            showFeedback(false, 'Network error occurred');
        });
    }

    function resetOrNext() {
        console.log('Moving to next question');
        // Hide feedback before navigating
        hideFeedback();
        // Reset panel color before navigating
        resetPanelColor();
        // Navigate to next question instead of just resetting inputs
        window.location.href = "{{ url_for(module_name + '.index') }}";
    }

    // Attach the function to the button click
    const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
    if (button) {
        button.onclick = handleCheckAnswers;
        // Initialize button state
        updateButton();
    } else {
        console.error('Button not found!');
    }

    // Add event listener for the "Enter" key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            handleCheckAnswers(event); // Call the handleCheckAnswers function
        }
    });
});

// Setup real-time conversion for hiragana input
document.addEventListener('DOMContentLoaded', function() {
	const hiraganaInput = document.getElementById('user_hiragana');
	const inputModes = templateSettings.inputModes || templateSettings.checkingStyles;
	const hasHiraganaChecking = inputModes && inputModes.includes('hiragana');

	
	if (hiraganaInput) {
		// console.log('Test conversion: ka =', convertRomajiToHiragana('ka'));
		
		hiraganaInput.addEventListener('input', function(e) {
			// Only convert if hiragana checking is enabled
			if (!hasHiraganaChecking) {
				return;
			}
			
			// Clear any existing timeout
			if (window.conversionTimeout) {
				clearTimeout(window.conversionTimeout);
			}
			
			// Set a short delay before converting to allow for complete syllable input
			window.conversionTimeout = setTimeout(() => {
				const cursorPos = e.target.selectionStart;
				const originalValue = e.target.value;
				const convertedValue = convertRomajiToHiragana(originalValue);
				
				if (convertedValue !== originalValue) {
					e.target.value = convertedValue;
					
					// Try to maintain cursor position
					const newCursorPos = Math.min(cursorPos, convertedValue.length);
					setTimeout(() => {
						e.target.setSelectionRange(newCursorPos, newCursorPos);
					}, 0);
				}
			}, 300); // 300ms delay - adjust as needed
		});
	}
});
</script>

{% endblock %}
