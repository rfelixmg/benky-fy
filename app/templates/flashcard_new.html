{% extends 'base.html' %}
{% block title %}{{ module_name|title }} | Benky-Fy{% endblock %}
{% block content %}
<meta name="user-authenticated" content="{% if current_user %}true{% else %}false{% endif %}">
<div class="flashcard-container">
	<section class="flashcard-module">
		<button class="settings-toggle-btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
		<header class="flashcard-header">
			<h1>{{ module_name|title }} Flashcards</h1>
		</header>
	
	<!-- Floating Settings Modal -->
	<div class="settings-modal" id="settingsModal">
		<div class="settings-modal-content">
			<div class="settings-modal-header">
				<h2>Settings</h2>
				<button class="settings-close-btn" onclick="toggleSettings()" title="Close">‚úï</button>
			</div>
			<div class="settings-body">
				<!-- Flashcard Display Mode Section -->
				<div class="settings-section">
					<div class="settings-section-header" onclick="toggleSection('flashcard-display')">
						<h3>Flashcard Display Mode</h3>
						<span class="section-toggle">‚ñº</span>
					</div>
					<div class="settings-section-content" id="flashcard-display">
						<div class="radio-group">
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kana" checked onchange="handleDisplayModeChange('kana')">
								<span>Kana</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kanji" onchange="handleDisplayModeChange('kanji')">
								<span>Kanji</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="kanji_furigana" onchange="handleDisplayModeChange('kanji_furigana')">
								<span>Kanji + Furigana</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="english" onchange="handleDisplayModeChange('english')">
								<span>English</span>
							</label>
							<label class="radio-option">
								<input type="radio" name="display_mode" value="weighted" onchange="handleDisplayModeChange('weighted')">
								<span>üîÑ Weighted Display</span>
							</label>
						</div>
						
						<!-- Kana Sub-toggle -->
						<div class="kana-toggle-panel" id="kana-toggle-panel" style="display: block;">
							<h4>Kana Type</h4>
							<div class="radio-group kana-sub-group">
								<label class="radio-option">
									<input type="radio" name="kana_type" value="hiragana" checked onchange="handleKanaTypeChange('hiragana')">
									<span>Hiragana</span>
								</label>
								<label class="radio-option">
									<input type="radio" name="kana_type" value="katakana" onchange="handleKanaTypeChange('katakana')">
									<span>Katakana</span>
								</label>
							</div>
						</div>
						
						<!-- Furigana Style Sub-panel (for Kanji + Furigana) -->
						<div class="weighted-panel" id="furigana-style-panel" style="display: none;">
							<h4>Furigana Style</h4>
						<label class="select-label">
								<span>Furigana Style</span>
								<select id="furigana-style" onchange="handleFuriganaStyleChange(this.value)">
									<option value="hover">Hover (tooltip on kanji)</option>
									<option value="inline">Inline (above or beside)</option>
									<option value="brackets">Brackets (e.g., È£ü[„Åü]„Åπ„Çã)</option>
									<option value="ruby" selected>Ruby (default browser <ruby>)</option>
							</select>
						</label>
						</div>
						
						<!-- Weighted Display Sub-panel -->
						<div class="weighted-panel" id="weighted-panel" style="display: none;">
							<h4>Display Weights</h4>
							<div class="slider-group">
								<label class="slider-label">
									<span>Kana</span>
									<input type="range" min="0" max="1" step="0.1" value="0.3" class="weight-slider" data-type="kana">
									<span class="slider-value">0.3</span>
								</label>
								<label class="slider-label">
									<span>Kanji</span>
									<input type="range" min="0" max="1" step="0.1" value="0.3" class="weight-slider" data-type="kanji">
									<span class="slider-value">0.3</span>
								</label>
								<label class="slider-label">
									<span>Kanji + Furigana</span>
									<input type="range" min="0" max="1" step="0.1" value="0.2" class="weight-slider" data-type="kanji_furigana">
									<span class="slider-value">0.2</span>
								</label>
								<label class="slider-label">
									<span>English</span>
									<input type="range" min="0" max="1" step="0.1" value="0.2" class="weight-slider" data-type="english">
									<span class="slider-value">0.2</span>
						</label>
							</div>
						</div>
					</div>
				</div>

				<!-- Answer Input Mode Section -->
				<div class="settings-section">
					<div class="settings-section-header" onclick="toggleSection('answer-input')">
						<h3>Answer Input Mode</h3>
						<span class="section-toggle">‚ñº</span>
					</div>
					<div class="settings-section-content" id="answer-input">
						<div class="checkbox-group">
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="hiragana" checked onchange="handleInputModeChange()">
								<span>Hiragana (romaji input ‚Üí auto-converts to kana)</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="romaji" onchange="handleInputModeChange()">
								<span>Romaji (as typed)</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="katakana" onchange="handleInputModeChange()">
								<span>Katakana</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="kanji" onchange="handleInputModeChange()">
								<span>Kanji</span>
							</label>
							<label class="checkbox-option">
								<input type="checkbox" name="input_modes" value="english" onchange="handleInputModeChange()">
								<span>English</span>
						</label>
						</div>
						<div class="helper-text">
							<p>You can select more than one. Your answer will be accepted if it matches any selected type.</p>
						</div>
					</div>
				</div>

				
				<div class="settings-actions">
					<button type="button" class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
					<button type="button" class="btn btn-secondary" onclick="resetToDefaults()">Reset to Defaults</button>
				</div>
			</div>
		</div>
	</div>
	
		<div class="flashcard-content">
			<div class="prompt-section">
				<p class="prompt-label">Prompt (<span id="prompt-script">{{ item.prompt_script }}</span>)</p>
				<div class="prompt-value" id="prompt-display">
					{% if item.prompt_script == 'kanji' and settings.show_furigana %}
						{% if settings.furigana_style == 'html' and item.furigana_html %}
							<div class="kanji-with-furigana">{{ item.furigana_html|safe }}</div>
						{% elif settings.furigana_style == 'text' and item.furigana_text %}
							<div class="kanji-with-furigana-text">{{ item.furigana_text }}</div>
						{% else %}
							<div class="kanji">{{ item.prompt }}</div>
						{% endif %}
					{% else %}
						<div class="prompt-text">{{ item.prompt }}</div>
					{% endif %}
				</div>
				{% if item.fallback_used %}
					<div class="fallback-notice" style="font-size: 0.8em; color: #666; margin-top: 5px;">
						‚ö†Ô∏è Fallback content used
					</div>
				{% endif %}
			</div>
			
			<div class="answer-section">
				{% set input_modes = settings.get('input_modes', settings.get('checking_styles', ['hiragana'])) %}
				{% set has_hiragana_romaji = 'hiragana' in input_modes or 'romaji' in input_modes %}
				{% set other_styles = input_modes | reject('in', ['hiragana', 'romaji']) | list %}
				
				{% if has_hiragana_romaji %}
				<div class="input-group">
					<label for="user_hiragana_romaji" class="input-label">
						Type in romaji (auto-converts to hiragana)
					</label>
					<input type="text" 
						   id="user_hiragana_romaji" 
						   name="user_hiragana_romaji" 
						   class="answer-input" 
						   placeholder="Type in romaji..." 
						   autofocus 
						   autocomplete="off" 
						   autocorrect="off" 
						   autocapitalize="off" 
						   spellcheck="false" />
				</div>
				{% endif %}
				
				{% for style in other_styles %}
				<div class="input-group">
					<label for="user_{{ style }}" class="input-label">Your answer ({{ style }}):</label>
					<input type="text" 
						   id="user_{{ style }}" 
						   name="user_{{ style }}" 
						   class="answer-input" 
						   placeholder="Type {{ style }}..." 
						   autocomplete="off" 
						   autocorrect="off" 
						   autocapitalize="off" 
						   spellcheck="false" />
				</div>
				{% endfor %}
			</div>
			
			<input type="hidden" id="item_id" name="item_id" value="{{ item.index }}">

			<div class="actions-section">
				<button type="button" class="check-button" id="checkButton" onclick="handleCheckAnswers()" disabled>Check Answer</button>
				<div class="branding-tooltip">powered by Benky-fy</div>
				<div class="feedback-message" id="feedbackMessage" style="display: none;"></div>
			</div>
		
		<!-- Always render the results container -->
		<div class="results-container">
			<!-- Initial content can be empty or a placeholder -->
		</div>

		{% if results is not none %}
		<div class="overall-result {{ 'correct' if all_correct else 'incorrect' }}">
			<p><strong>{{ 'All Correct!' if all_correct else 'Some Incorrect' }}</strong></p>
		</div>
			
		{% for style, result in results.items() %}
		<div class="result {{ 'correct' if result.is_correct else 'incorrect' }}">
			<h4>{{ style.title() }}</h4>
			<p>Your answer: <code>{{ result.user_input or '(empty)' }}</code></p>
			<p>Correct answer: <code>{{ result.correct_answer }}</code></p>
			<p class="result-status">{{ '‚úì Correct' if result.is_correct else '‚úó Incorrect' }}</p>
		</div>
		{% endfor %}

		<button class="btn" onclick="goToNext()">
			Next ‚û°Ô∏è
		</button>

		{% endif %}
		</div>
	</section>
</div>

<script src="{{ url_for('static', filename='js/utils.js') }}"></script>

<script>
// Template variables
const templateSettings = {
	inputModes: ["hiragana"],
	checkingStyles: ["hiragana"] // fallback for compatibility
};
</script>

<script>
// Settings management
function toggleSettings() {
	const settingsModal = document.getElementById('settingsModal');
	if (settingsModal) {
		settingsModal.classList.toggle('show');
	}
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
	const settingsModal = document.getElementById('settingsModal');
	const settingsModalContent = document.querySelector('.settings-modal-content');
	
	if (settingsModal && settingsModal.classList.contains('show')) {
		if (!settingsModalContent.contains(event.target) && !event.target.closest('.settings-toggle-btn')) {
			settingsModal.classList.remove('show');
		}
	}
});

// Settings state management
let settingsState = {
	displayMode: 'kana',
	kanaTypes: ['hiragana'],
	inputModes: ['hiragana'],
	furiganaStyle: 'ruby',
	weights: {
		kana: 0.3,
		kanji: 0.3,
		kanji_furigana: 0.2,
		english: 0.2
	}
};

// Track user interactions to prevent API calls on page load
let isUserInteraction = false;
let isPageLoaded = false;

// Collapsible section management
function toggleSection(sectionId) {
	const content = document.getElementById(sectionId);
	const header = content.previousElementSibling;
	const toggle = header.querySelector('.section-toggle');
	
	if (content.style.display === 'none' || content.style.display === '') {
		content.style.display = 'block';
		toggle.textContent = '‚ñ≤';
		header.classList.add('expanded');
	} else {
		content.style.display = 'none';
		toggle.textContent = '‚ñº';
		header.classList.remove('expanded');
	}
}

// Display mode change handler
function handleDisplayModeChange(mode) {
	settingsState.displayMode = mode;
	const weightedPanel = document.getElementById('weighted-panel');
	const kanaTogglePanel = document.getElementById('kana-toggle-panel');
	const furiganaStylePanel = document.getElementById('furigana-style-panel');
	
	if (mode === 'weighted') {
		weightedPanel.style.display = 'block';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'block';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kanji_furigana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'block';
	} else {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	}
	
	// Update live preview if present
	updateLivePreview();
}

// Kana types change handler (multi-select)
function handleKanaTypesChange() {
	const kanaCheckboxes = document.querySelectorAll('input[name="kana_types"]:checked');
	settingsState.kanaTypes = Array.from(kanaCheckboxes).map(cb => cb.value);
	// In the future, alternate or randomize if both are selected
	updateLivePreview();
}

// Furigana style change handler
function handleFuriganaStyleChange(style) {
	isUserInteraction = true;
	settingsState.furiganaStyle = style;
	updateLivePreview();
}

// Input mode change handler
function handleInputModeChange() {
	const checkboxes = document.querySelectorAll('input[name="input_modes"]:checked');
	settingsState.inputModes = Array.from(checkboxes).map(cb => cb.value);
	
	// Update check button state
	updateCheckButtonState();
	
	// Update live preview if present
	updateLivePreview();
}

// Update check button state based on input modes
function updateCheckButtonState() {
	const checkButton = document.getElementById('checkButton');
	if (checkButton) {
		checkButton.disabled = settingsState.inputModes.length === 0;
	}
}


// Weight slider change handler
function handleWeightChange(slider) {
	isUserInteraction = true;
	const type = slider.dataset.type;
	const value = parseFloat(slider.value);
	
	settingsState.weights[type] = value;
	
	// Update the displayed value
	const valueSpan = slider.parentElement.querySelector('.slider-value');
	valueSpan.textContent = value.toFixed(1);
	
	// Update live preview if present
	updateLivePreview();
	
	// Update display text if in weighted mode
	const currentMode = document.querySelector('input[name="display_mode"]:checked')?.value;
	if (currentMode === 'weighted') {
		updateDisplayText();
	}
}

// Live preview update (placeholder for future implementation)
function updateLivePreview() {
	// This would update a live preview of the flashcard display
	// For now, just log the current state
	console.log('Settings updated:', settingsState);
}

// Check if user is authenticated
function checkAuthenticationStatus() {
	// Check for common authentication indicators
	const hasUserSession = document.querySelector('meta[name="user-authenticated"]')?.content === 'true';
	const hasAuthCookie = document.cookie.includes('session=') || document.cookie.includes('flask-session=');
	const isOnAuthPage = window.location.pathname.includes('/auth/') || window.location.pathname.includes('/login');
	
	// If we're on an auth page, definitely not authenticated
	if (isOnAuthPage) {
		return false;
	}
	
	// If we have explicit session indicators, we're authenticated
	if (hasUserSession || hasAuthCookie) {
		return true;
	}
	
	// Default to false for safety
	return false;
}

// Enhanced display text handler with full backend integration
function updateDisplayText() {
	const itemId = document.querySelector('input[name="item_id"]')?.value;
	if (!itemId) {
		console.log('No item_id found, skipping display text update');
		return;
	}
	
	// Get current settings from the form
	const displayMode = document.querySelector('input[name="display_mode"]:checked')?.value || 'kana';
	const kanaType = document.querySelector('input[name="kana_type"]:checked')?.value || 'hiragana';
	const furiganaStyle = document.getElementById('furigana-style')?.value || 'ruby';
	
	// Build settings object with all current settings
	const settings = {
		display_mode: displayMode,
		kana_type: kanaType,
		furigana_style: furiganaStyle,
		proportions: getCurrentProportions()
	};
	
	// Send request to get display text
	fetch(`/begginer/{{ module_name }}/api/display-text?item_id=${itemId}`, {
		method: 'GET',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		if (response.status === 401 || response.status === 403) {
			// Authentication required, use test endpoint for development
			console.log('Auth required, using test endpoint');
			return fetch(`/begginer/{{ module_name }}/api/test-display-text?item_id=${itemId}&display_mode=${settings.display_mode}&kana_type=${settings.kana_type}`);
		}
		return response;
	})
	.then(response => response.json())
	.then(data => {
		if (data.error) {
			console.error('Error getting display text:', data.error);
			showDisplayError('Failed to load display text');
			return;
		}
		
		// Update the prompt display with enhanced rendering
		updatePromptDisplay(data, settings);
		
		// Log display constraints for debugging
		console.log('Display updated:', {
			mode: data.mode,
			script: data.script,
			text: data.text,
			fallback_used: data.fallback_used,
			settings: settings
		});
	})
	.catch(error => {
		console.error('Error updating display text:', error);
		showDisplayError('Network error loading display text');
	});
}

// Enhanced prompt display update with proper styling and fallbacks
function updatePromptDisplay(data, settings) {
	const promptDisplay = document.getElementById('prompt-display');
	const promptScript = document.getElementById('prompt-script');
	const fallbackNotice = document.querySelector('.fallback-notice');
	
	if (!promptDisplay || !promptScript) {
		console.error('Required DOM elements not found');
		return;
	}
	
	// Clear existing content
	promptDisplay.innerHTML = '';
	
	// Handle "N/A" fallback case
	if (data.text === "N/A" || data.script === "error") {
		showDisplayError('Content not available for this display mode');
		return;
	}
	
	// Create appropriate display element based on script type and settings
	let displayElement = createDisplayElement(data, settings);
	promptDisplay.appendChild(displayElement);
	
	// Update script indicator
	promptScript.textContent = data.script;
	
	// Show/hide fallback notice
	if (fallbackNotice) {
		fallbackNotice.style.display = data.fallback_used ? 'block' : 'none';
	}
}

// Create display element with proper styling and furigana handling
function createDisplayElement(data, settings) {
	const displayElement = document.createElement('div');
	
	// Apply base styling based on script type
	switch (data.script) {
		case 'kanji_furigana':
			displayElement.className = 'kanji-with-furigana';
			// Handle different furigana styles
			applyFuriganaStyle(displayElement, data.text, settings.furigana_style);
			break;
			
		case 'kanji':
			displayElement.className = 'kanji';
			displayElement.textContent = data.text;
			break;
			
		case 'hiragana':
		case 'katakana':
			displayElement.className = 'prompt-text';
			displayElement.textContent = data.text;
			// Add script-specific styling
			displayElement.setAttribute('data-script', data.script);
			break;
			
		case 'english':
			displayElement.className = 'prompt-text english-text';
			displayElement.textContent = data.text;
			break;
			
		default:
			displayElement.className = 'prompt-text';
			displayElement.textContent = data.text;
	}
	
	return displayElement;
}

// Apply furigana styling based on user preference
function applyFuriganaStyle(element, text, furiganaStyle) {
	switch (furiganaStyle) {
		case 'ruby':
			// Default HTML ruby tags (backend provides this)
			element.innerHTML = text;
			break;
			
		case 'brackets':
			// Convert ruby tags to bracket format: È£ü[„Åü]„Åπ„Çã
			element.innerHTML = convertRubyToBrackets(text);
			break;
			
		case 'hover':
			// Convert to hover tooltip format
			element.innerHTML = convertRubyToHover(text);
			break;
			
		case 'inline':
			// Convert to inline format: „Åü„Åπ„Çã (È£ü)
			element.innerHTML = convertRubyToInline(text);
			break;
			
		default:
			// Fallback to ruby
			element.innerHTML = text;
	}
}

// Convert ruby tags to bracket format
function convertRubyToBrackets(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, '$1[$2]');
}

// Convert ruby tags to hover tooltip format
function convertRubyToHover(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, 
		'<span class="kanji-hover" title="$2">$1</span>');
}

// Convert ruby tags to inline format
function convertRubyToInline(html) {
	return html.replace(/<ruby><rb>([^<]+)<\/rb><rt>([^<]+)<\/rt><\/ruby>/g, '$2 ($1)');
}

// Show display error message
function showDisplayError(message) {
	const promptDisplay = document.getElementById('prompt-display');
	if (promptDisplay) {
		promptDisplay.innerHTML = `
			<div class="display-error">
				<span class="error-icon">‚ö†Ô∏è</span>
				<span class="error-message">${message}</span>
			</div>
		`;
	}
}

// Get current proportions from sliders
function getCurrentProportions() {
	const proportions = {};
	const sliders = document.querySelectorAll('.slider-group input[type="range"]');
	sliders.forEach(slider => {
		const type = slider.getAttribute('data-type');
		if (type) {
			proportions[type] = parseFloat(slider.value);
		}
	});
	return proportions;
}

// Enhanced display mode change handler with live preview
function handleDisplayModeChange(mode) {
	// Mark as user interaction
	isUserInteraction = true;
	
	settingsState.displayMode = mode;
	const weightedPanel = document.getElementById('weighted-panel');
	const kanaTogglePanel = document.getElementById('kana-toggle-panel');
	const furiganaStylePanel = document.getElementById('furigana-style-panel');
	
	if (mode === 'weighted') {
		weightedPanel.style.display = 'block';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'block';
		furiganaStylePanel.style.display = 'none';
	} else if (mode === 'kanji_furigana') {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'block';
	} else {
		weightedPanel.style.display = 'none';
		kanaTogglePanel.style.display = 'none';
		furiganaStylePanel.style.display = 'none';
	}
	
	// Update display text with new constraints
	updateDisplayText();
}

// Force display text update (for user interactions)
function forceUpdateDisplayText() {
	console.log('Force updating display text...');
	updateDisplayText();
}

// Kana type change handler
function handleKanaTypeChange(type) {
	isUserInteraction = true;
	settingsState.kanaTypes = [type];
	
	// Update display text if in kana mode
	const currentMode = document.querySelector('input[name="display_mode"]:checked')?.value;
	if (currentMode === 'kana') {
		updateDisplayText();
	}
}

// Save settings (frontend only for now)
function saveSettings() {
	// Store settings in localStorage for persistence
	localStorage.setItem('flashcardSettings', JSON.stringify(settingsState));
	
	// Show success feedback
	const saveButton = document.querySelector('.btn-primary');
	const originalText = saveButton.textContent;
	saveButton.textContent = 'Saved!';
	saveButton.style.backgroundColor = '#10b981';
	
	setTimeout(() => {
		saveButton.textContent = originalText;
		saveButton.style.backgroundColor = '';
	}, 2000);
	
	// Close modal
	toggleSettings();
}

// Load settings from localStorage
function loadSettings() {
	const saved = localStorage.getItem('flashcardSettings');
	if (saved) {
		settingsState = { ...settingsState, ...JSON.parse(saved) };
		applySettingsToUI();
	}
}

// Apply loaded settings to UI
function applySettingsToUI() {
	// Apply display mode
	const displayRadios = document.querySelectorAll('input[name="display_mode"]');
	displayRadios.forEach(radio => {
		if (radio.value === settingsState.displayMode) {
			radio.checked = true;
			handleDisplayModeChange(settingsState.displayMode);
		}
	});
	
	// Apply kana types (checkboxes)
	const kanaCheckboxesAll = document.querySelectorAll('input[name="kana_types"]');
	kanaCheckboxesAll.forEach(cb => {
		cb.checked = settingsState.kanaTypes.includes(cb.value);
	});
	
	// Apply input modes
	const inputCheckboxes = document.querySelectorAll('input[name="input_modes"]');
	inputCheckboxes.forEach(checkbox => {
		checkbox.checked = settingsState.inputModes.includes(checkbox.value);
	});
	
	// Apply furigana style
	const furiganaStyleSelect = document.getElementById('furigana-style');
	if (furiganaStyleSelect) {
		furiganaStyleSelect.value = settingsState.furiganaStyle;
	}
	
	// Apply weights
	Object.keys(settingsState.weights).forEach(type => {
		const slider = document.querySelector(`[data-type="${type}"]`);
		if (slider) {
			slider.value = settingsState.weights[type];
			const valueSpan = slider.parentElement.querySelector('.slider-value');
			valueSpan.textContent = settingsState.weights[type].toFixed(1);
		}
	});
	
	// Update check button state
	updateCheckButtonState();
}

function resetToDefaults() {
	if (confirm('Are you sure you want to reset all settings to their default values?')) {
		// Reset to default state
		settingsState = {
			displayMode: 'kana',
			kanaTypes: ['hiragana'],
			inputModes: ['hiragana'],
			furiganaStyle: 'ruby',
			weights: {
				kana: 0.3,
				kanji: 0.3,
				kanji_furigana: 0.2,
				english: 0.2
			}
		};
		
		// Apply defaults to UI
		applySettingsToUI();
		
		// Clear localStorage
		localStorage.removeItem('flashcardSettings');
		
		// Show feedback
		const resetButton = document.querySelector('.btn-secondary');
		const originalText = resetButton.textContent;
		resetButton.textContent = 'Reset!';
		resetButton.style.backgroundColor = '#f59e0b';
		
		setTimeout(() => {
			resetButton.textContent = originalText;
			resetButton.style.backgroundColor = '';
		}, 2000);
	}
}

// Initialize settings on page load
document.addEventListener('DOMContentLoaded', function() {
	// Mark page as loaded
	isPageLoaded = true;
	
	// Load saved settings
	loadSettings();
	
	// Add event listeners for weight sliders
	const weightSliders = document.querySelectorAll('.weight-slider');
	weightSliders.forEach(slider => {
		slider.addEventListener('input', function() {
			handleWeightChange(this);
		});
	});
	
	// Initialize all sections as collapsed
	const sections = ['flashcard-display', 'answer-input'];
	sections.forEach(sectionId => {
		const content = document.getElementById(sectionId);
		if (content) {
			content.style.display = 'none';
		}
	});
});

// Rest of the existing JavaScript functions...
function checkEnglishAnswer(userInput, correctAnswersText) {
    /**
     * Enhanced English answer checking that handles multiple formats:
     * 1. Multiple meanings separated by " / " (e.g., "simple / easy")
     * 2. Comma-separated meanings (e.g., "tough, serious")
     * 3. Verb variations with/without "to" (e.g., "to look" accepts "look")
     * 4. Flexible matching for common variations
     */
    if (!userInput) {
        return false;
    }
    
    // First, try the original " / " format
    if (correctAnswersText.includes(" / ")) {
        const correctAnswers = correctAnswersText.split(" / ").map(answer => answer.trim().toLowerCase());
        if (correctAnswers.includes(userInput)) {
            return true;
        }
    }
    
    // Handle comma-separated meanings (e.g., "tough, serious")
    if (correctAnswersText.includes(",") && !correctAnswersText.includes(" / ")) {
        const correctAnswers = correctAnswersText.split(",").map(answer => answer.trim().toLowerCase());
        if (correctAnswers.includes(userInput)) {
            return true;
        }
    }
    
    // Handle verb variations (with/without "to")
    // Check if the correct answer starts with "to " and user input doesn't
    if (correctAnswersText.toLowerCase().startsWith("to ")) {
        const verbWithoutTo = correctAnswersText.substring(3).trim().toLowerCase(); // Remove "to " prefix
        if (userInput === verbWithoutTo) {
            return true;
        }
    }
    
    // Check if user input starts with "to " but correct answer doesn't
    if (userInput.startsWith("to ")) {
        const verbWithoutTo = userInput.substring(3).trim(); // Remove "to " prefix
        if (verbWithoutTo === correctAnswersText.toLowerCase()) {
            return true;
        }
    }
    
    // Handle multiple verb forms in comma-separated format
    if (correctAnswersText.includes(",")) {
        const answers = correctAnswersText.split(",").map(answer => answer.trim().toLowerCase());
        for (const answer of answers) {
            // Check exact match
            if (userInput === answer) {
                return true;
            }
            // Check verb variations
            if (answer.startsWith("to ") && userInput === answer.substring(3).trim()) {
                return true;
            }
            if (userInput.startsWith("to ") && answer === userInput.substring(3).trim()) {
                return true;
            }
        }
    }
    
    // Fallback: exact match (case-insensitive)
    return userInput === correctAnswersText.toLowerCase();
}

function goToNext() {
	window.location.href = "{{ url_for(module_name + '.index') }}";
}

function getFriendlyStyleName(style) {
    const styleMap = {
        'hiragana_romaji': 'Hiragana/Romaji',
        'hiragana': 'Hiragana',
        'romaji': 'Romaji',
        'kanji': 'Kanji',
        'katakana': 'Katakana',
        'english': 'English'
    };
    return styleMap[style] || style.charAt(0).toUpperCase() + style.slice(1);
}

function fetchCorrectAnswers() {
    // Get the item ID from the hidden input
    const itemId = document.getElementById('item_id').value;
    
    // Define the API endpoint with item_id parameter
    const apiUrl = `{{ url_for(module_name + '.get_correct_answers') }}?item_id=${itemId}`;

    // Make the API request
    return fetch(apiUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            // Return the data directly since it's already in the correct format
            return data;
        })
        .catch(error => {
            console.error('Error fetching correct answers:', error);
            return null;
        });
}

document.addEventListener('DOMContentLoaded', function() {
    let resultsShown = false; // Define resultsShown in the correct scope
    let feedbackTimeout = null; // For managing feedback persistence

    // Initialize flashcard module color to waiting state
    const flashcardModule = document.querySelector('.flashcard-module');
    if (flashcardModule) {
        flashcardModule.classList.add('waiting'); // White for waiting answer
    }

    // Initialize button state and input monitoring
    const checkButton = document.getElementById('checkButton');
    const answerInput = document.getElementById('user_hiragana_romaji');
    
    function updateButtonState() {
        if (checkButton && answerInput) {
            const hasInput = answerInput.value.trim().length > 0;
            checkButton.disabled = !hasInput || resultsShown;
            console.log('Button state updated:', { hasInput, resultsShown, disabled: checkButton.disabled });
        }
    }
    
    // Monitor input changes
    if (answerInput) {
        answerInput.addEventListener('input', updateButtonState);
        answerInput.addEventListener('keyup', updateButtonState);
    }
    
    // Initial button state
    updateButtonState();

    function showFeedback(isCorrect, correctAnswer = '') {
        const feedbackMessage = document.getElementById('feedbackMessage');
        if (!feedbackMessage) return;
        
        // Clear any existing timeout
        if (feedbackTimeout) {
            clearTimeout(feedbackTimeout);
        }
        
        // Show feedback
        feedbackMessage.style.display = 'flex';
        feedbackMessage.className = 'feedback-message ' + (isCorrect ? 'correct' : 'incorrect');
        
        if (isCorrect) {
            feedbackMessage.innerHTML = '‚úÖ Correct!';
        } else {
            feedbackMessage.innerHTML = `‚ùå Incorrect. The answer was: <strong>${correctAnswer}</strong>`;
        }
        
        // Auto-hide after 3 seconds
        feedbackTimeout = setTimeout(() => {
            feedbackMessage.style.display = 'none';
        }, 3000);
    }
    
    function hideFeedback() {
        const feedbackMessage = document.getElementById('feedbackMessage');
        if (feedbackMessage) {
            feedbackMessage.style.display = 'none';
        }
        if (feedbackTimeout) {
            clearTimeout(feedbackTimeout);
            feedbackTimeout = null;
        }
    }

    function updateButton() {
        const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
        if (button) {
            if (resultsShown) {
                button.textContent = 'Next ‚û°Ô∏è';
                button.classList.add('next-button');
                button.classList.remove('check-button');
                button.disabled = false;
            } else {
                button.textContent = 'Check Answer';
                button.classList.add('check-button');
                button.classList.remove('next-button');
                updateButtonState(); // Re-evaluate button state
            }
        }
    }

    function resetPanelColor() {
        const flashcardModuleElement = document.querySelector('.flashcard-module');
        if (flashcardModuleElement) {
            flashcardModuleElement.classList.remove('waiting', 'correct', 'incorrect');
            flashcardModuleElement.classList.add('waiting'); // Reset to white waiting state
        }
    }

    function handleCheckAnswers(event) {
        console.log('handleCheckAnswers called', { event, resultsShown });
        
        if (event) {
            event.preventDefault(); // Prevent default behavior
        }

        if (resultsShown) {
            resetOrNext();
            return;
        }

        // Retrieve user inputs
        const userInputs = {};
        const inputElements = document.querySelectorAll('.answer-input');
        inputElements.forEach(input => {
            userInputs[input.name] = input.value.trim();
        });

        // Fetch correct answers
        fetchCorrectAnswers().then(correctAnswers => {
            if (!correctAnswers) {
                console.error('Failed to fetch correct answers');
                return;
            }

            // Compare user inputs with correct answers
            const results = {};
            let allCorrect = true;
            
            console.log('=== Answer Check Results ===');
            
            for (const [key, userInput] of Object.entries(userInputs)) {
                const correctAnswerText = correctAnswers[key];
                let isCorrect = false;
                
                // Enhanced English answer checking
                if (key === "user_english" && correctAnswerText) {
                    isCorrect = checkEnglishAnswer(userInput.toLowerCase(), correctAnswerText);
                } else {
                    // Simple exact match for other types
                    isCorrect = userInput === correctAnswerText;
                }
                
                results[key] = {
                    user_input: userInput,
                    correct_answer: correctAnswerText,
                    is_correct: isCorrect
                };
                
                // Log each result
                const style = key.replace('user_', '');
                console.log(`${style.toUpperCase()}:`);
                console.log(`  Your answer: "${userInput}"`);
                console.log(`  Correct answer: "${correctAnswerText}"`);
                console.log(`  Result: ${isCorrect ? '‚úÖ CORRECT' : '‚ùå INCORRECT'}`);
                console.log('---');
                
                if (!isCorrect) {
                    allCorrect = false;
                }
            }
            
            console.log(`Overall Result: ${allCorrect ? 'üéâ ALL CORRECT!' : 'üìù Some answers need work'}`);
            console.log('=============================');

            // Hide any existing feedback
            hideFeedback();
            
            // Show feedback message
            const inputModes = templateSettings.inputModes || templateSettings.checkingStyles;
            const primaryStyle = inputModes && inputModes[0] ? inputModes[0] : 'hiragana'; // Get the primary input mode
            const primaryResult = results[`user_${primaryStyle}`] || results[Object.keys(results)[0]];
            const correctAnswer = primaryResult ? primaryResult.correct_answer : '';
            
            showFeedback(allCorrect, correctAnswer);
            
            // Update the UI with results
            const resultsContainer = document.querySelector('.results-container');
            if (!resultsContainer) {
                console.error('Results container not found!');
                return;
            }
            resultsContainer.style.display = 'block'; // Ensure it's visible
            resultsContainer.innerHTML = ''; // Clear previous results
            
            // Change flashcard module color based on results
            const flashcardModuleElement = document.querySelector('.flashcard-module');
            if (flashcardModuleElement) {
                // Remove any existing color classes
                flashcardModuleElement.classList.remove('waiting', 'correct', 'incorrect');
                
                if (allCorrect) {
                    flashcardModuleElement.classList.add('correct'); // Green for all correct
                } else {
                    flashcardModuleElement.classList.add('incorrect'); // Red for some incorrect
                }
            }
            
            // Create a single unified results box
            const unifiedResultsBox = document.createElement('div');
            unifiedResultsBox.className = 'unified-results';
            
            // Build the content for the unified box (removed overall-status div)
            let resultsHTML = '<div class="results-list">';
            
            // Add individual results to the same container
            for (const [style, result] of Object.entries(results)) {
                // Skip if the correct answer is empty or just a dash (like katakana when not available)
                if (!result.correct_answer || result.correct_answer === '‚Äì' || result.correct_answer.trim() === '') {
                    continue;
                }
                
                // Clean style name for display with user-friendly labels
                const styleName = getFriendlyStyleName(style.replace('user_', ''));
                
                resultsHTML += `
                    <div class="result-item ${result.is_correct ? 'correct' : 'incorrect'}">
                        <span class="style-name">${styleName}</span>
                        <span class="result-status">${result.is_correct ? '‚úì' : '‚úó'}</span>
                        <span class="user-answer">Your answer: <code>${result.user_input || '(empty)'}</code></span>
                        ${!result.is_correct ? `<span class="correct-answer">Correct: <code>${result.correct_answer}</code></span>` : ''}
                    </div>
                `;
            }
            
            resultsHTML += '</div>';
            unifiedResultsBox.innerHTML = resultsHTML;
            resultsContainer.appendChild(unifiedResultsBox);

            resultsShown = true; // Set flag to true after showing results
            updateButton(); // Update button text and style
        });
    }

    function resetOrNext() {
        console.log('Moving to next question');
        // Hide feedback before navigating
        hideFeedback();
        // Reset panel color before navigating
        resetPanelColor();
        // Navigate to next question instead of just resetting inputs
        window.location.href = "{{ url_for(module_name + '.index') }}";
    }

    // Attach the function to the button click
    const button = document.querySelector('button[onclick="handleCheckAnswers()"]');
    if (button) {
        button.onclick = handleCheckAnswers;
        // Initialize button state
        updateButton();
    } else {
        console.error('Button not found!');
    }

    // Add event listener for the "Enter" key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            handleCheckAnswers(event); // Call the handleCheckAnswers function
        }
    });
});

// Setup real-time conversion for hiragana input
document.addEventListener('DOMContentLoaded', function() {
	const hiraganaRomajiInput = document.getElementById('user_hiragana_romaji');
	const inputModes = templateSettings.inputModes || templateSettings.checkingStyles;
	const hasHiraganaChecking = inputModes && inputModes.includes('hiragana');

	
	if (hiraganaRomajiInput) {
		// console.log('Test conversion: ka =', convertRomajiToHiragana('ka'));
		
		hiraganaRomajiInput.addEventListener('input', function(e) {
			// Only convert if hiragana checking is enabled
			if (!hasHiraganaChecking) {
				return;
			}
			
			// Clear any existing timeout
			if (window.conversionTimeout) {
				clearTimeout(window.conversionTimeout);
			}
			
			// Set a short delay before converting to allow for complete syllable input
			window.conversionTimeout = setTimeout(() => {
				const cursorPos = e.target.selectionStart;
				const originalValue = e.target.value;
				const convertedValue = convertRomajiToHiragana(originalValue);
				
				if (convertedValue !== originalValue) {
					e.target.value = convertedValue;
					
					// Try to maintain cursor position
					const newCursorPos = Math.min(cursorPos, convertedValue.length);
					setTimeout(() => {
						e.target.setSelectionRange(newCursorPos, newCursorPos);
					}, 0);
				}
			}, 300); // 300ms delay - adjust as needed
		});
	}
});
</script>

{% endblock %}
